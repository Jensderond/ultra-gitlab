# Ralph Progress Log
Started: Fri Feb 13 11:58:05 CET 2026

## Codebase Patterns
- DB migrations: numbered `0001_xxx.sql` files in `src-tauri/src/db/migrations/`, registered via `include_str!` in MIGRATIONS array in `db/mod.rs`
- DB query modules: `src-tauri/src/db/<feature>.rs`, registered as `pub mod` in `db/mod.rs`
- Models: `src-tauri/src/models/<feature>.rs` with `#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]` and `#[serde(rename_all = "camelCase")]`
- Commands: `src-tauri/src/commands/<feature>.rs`, re-exported in `commands/mod.rs`, imported and added to `generate_handler!` in `lib.rs`
- Commands use `State<'_, DbPool>` for DB access, return `Result<T, AppError>`
- Single-row settings pattern: use `id INTEGER PRIMARY KEY DEFAULT 1` with `INSERT OR IGNORE` for seed
- Settings page sections: `<section className="settings-section"><h2>Title</h2>...</section>`, reuse `.sync-settings-form`, `.checkbox-group`, `.checkbox-label` classes
- Tauri plugins: add to Cargo.toml (version "2"), register `.plugin(plugin_name::init())` in lib.rs builder, add permission to capabilities/default.json
- Commands needing AppHandle use `app: tauri::AppHandle` param (not State), useful for plugin APIs like `app.notification()`
- Adding a column to merge_requests: migration, model struct, GitLabMergeRequest API struct, sync_engine upsert, MergeRequestListItem DTO + From impl, 3 SELECT queries in commands/mr.rs, frontend MergeRequest type
- SyncEngine `&mut self` methods: must `drop()` any RwLockReadGuard (e.g., config) before calling, since borrow checker prevents simultaneous immutable + mutable borrows
- Sync events: constants + payload structs in sync_events.rs, imported in sync_engine.rs, emitted via `self.app_handle.emit(EVENT, payload)`

---

## 2026-02-13 - US-001
- What was implemented: notification_settings DB table, migration, model, db query functions, and Tauri commands (get/update)
- Files changed:
  - `src-tauri/src/db/migrations/0011_create_notification_settings.sql` (new)
  - `src-tauri/src/db/mod.rs` (added migration + module)
  - `src-tauri/src/db/notification_settings.rs` (new)
  - `src-tauri/src/models/notification_settings.rs` (new)
  - `src-tauri/src/models/mod.rs` (added module + re-export)
  - `src-tauri/src/commands/notification_settings.rs` (new)
  - `src-tauri/src/commands/mod.rs` (added module + re-exports)
  - `src-tauri/src/lib.rs` (added imports + generate_handler entries)
- **Learnings for future iterations:**
  - 3 registration points for new commands: command file, commands/mod.rs re-export, lib.rs import + generate_handler
  - DB modules go in both db/mod.rs (pub mod) and the model goes in models/mod.rs
  - `sqlx::Error` auto-converts to `AppError` via the `From` impl so `?` works seamlessly
---

## 2026-02-13 - US-002
- What was implemented: Frontend TypeScript interface and service wrappers for notification settings
- Files changed:
  - `src/types/index.ts` (added NotificationSettings interface)
  - `src/services/tauri.ts` (added getNotificationSettings + updateNotificationSettings invoke wrappers)
  - `src/services/index.ts` (re-exported new functions)
- **Learnings for future iterations:**
  - Frontend service layer pattern: type in `types/index.ts` → import in `services/tauri.ts` → invoke wrapper → re-export in `services/index.ts`
  - Rust model `#[serde(rename_all = "camelCase")]` means frontend types use camelCase field names (e.g., `mr_ready_to_merge` → `mrReadyToMerge`)
  - Tauri command arg names in invoke must match the Rust function parameter names exactly (e.g., `{ settings }` for `update_notification_settings(settings: ...)`)
---

## 2026-02-13 - US-003
- What was implemented: Notifications section in Settings page with three toggles (MR ready to merge, Pipeline status, Native OS notifications)
- Files changed:
  - `src/pages/Settings.tsx` (added notification settings state, load/save handlers, and Notifications section UI)
  - `src/pages/Settings.css` (added `.checkbox-description` style, adjusted `.checkbox-label` alignment for multi-line content)
- **Learnings for future iterations:**
  - Settings page sections follow a consistent pattern: `<section className="settings-section"><h2>Title</h2>...</section>`
  - Reuse existing CSS classes like `.sync-settings-form`, `.checkbox-group`, `.checkbox-label`, `.saving-indicator` for new settings sections
  - For optimistic UI on toggle save: update state immediately, then save async, and rollback on error
  - When adding descriptions below checkbox labels, use `align-items: flex-start` on the flex container and `flex-shrink: 0` on the checkbox input
---

## 2026-02-13 - US-004
- What was implemented: Installed and configured tauri-plugin-notification, created send_native_notification Tauri command
- Files changed:
  - `src-tauri/Cargo.toml` (added tauri-plugin-notification = "2")
  - `src-tauri/src/lib.rs` (registered plugin + imported/registered send_native_notification command)
  - `src-tauri/capabilities/default.json` (added "notification:default" permission)
  - `src-tauri/src/commands/notifications.rs` (new — send_native_notification command using NotificationExt)
  - `src-tauri/src/commands/mod.rs` (added module + re-export)
- **Learnings for future iterations:**
  - tauri-plugin-notification uses `NotificationExt` trait — call `app.notification().builder().title().body().show()`
  - Commands that need plugin APIs use `app: tauri::AppHandle` parameter instead of `State<'_, DbPool>`
  - Plugin permissions follow pattern: `"<plugin-name>:default"` in capabilities/default.json
  - On desktop, notification permissions are typically granted by default; `.show()` returns an error if denied
---

## 2026-02-13 - US-005
- What was implemented: Added head_pipeline_status field across the full stack (DB → Rust model → API struct → sync engine → command DTO → frontend types)
- Files changed:
  - `src-tauri/src/db/migrations/0012_add_head_pipeline_status.sql` (new — ALTER TABLE adds nullable column)
  - `src-tauri/src/db/mod.rs` (registered migration 0012)
  - `src-tauri/src/services/gitlab_client.rs` (added GitLabHeadPipeline helper struct + head_pipeline field on GitLabMergeRequest)
  - `src-tauri/src/models/merge_request.rs` (added head_pipeline_status: Option<String>)
  - `src-tauri/src/services/sync_engine.rs` (extract head_pipeline.status in upsert_mr, add to INSERT + ON CONFLICT UPDATE)
  - `src-tauri/src/commands/mr.rs` (added head_pipeline_status to MergeRequestListItem struct, From impl, and 3 SELECT queries)
  - `src/types/index.ts` (added headPipelineStatus: string | null to MergeRequest interface)
- **Learnings for future iterations:**
  - GitLab API returns `head_pipeline` as a nested object with a `status` field — need a helper struct to deserialize, then extract `.status` in sync
  - When adding a new column to merge_requests, must update: model struct, command DTO, From impl, all SELECT queries (3 in mr.rs), sync engine INSERT/UPDATE, and frontend type
  - ALTER TABLE ADD COLUMN migrations are simpler than full table recreations — just add nullable column
  - The 3 SELECT queries in mr.rs that need updating: get_merge_requests, list_my_merge_requests, get_merge_request_detail
---

## 2026-02-13 - US-006
- What was implemented: MR ready-to-merge transition detection in sync_engine with Tauri event emission
- Files changed:
  - `src-tauri/src/services/sync_events.rs` (added MR_READY_EVENT constant + MrReadyPayload struct)
  - `src-tauri/src/services/sync_engine.rs` (added MrReadyState query struct, in-memory HashSet for dedup, get_ready_states/is_mr_ready/check_mr_ready_transitions methods, wired into sync_instance after MR processing)
- **Learnings for future iterations:**
  - When adding `&mut self` to methods in SyncEngine, must explicitly `drop(config)` the RwLockReadGuard before calling mutable methods — Rust borrow checker requires it
  - Transition detection pattern: snapshot DB state before sync, compare after sync, emit event only on state change
  - Ready-to-merge condition: approval_status='approved' AND approvals_count >= approvals_required AND head_pipeline_status='success'
  - In-memory HashSet<i64> on the engine struct avoids duplicate notifications within a session without needing DB storage
  - The sync engine background task owns the engine as `let mut engine`, so `&mut self` methods work fine
---
