## Codebase Patterns
- Sync engine in src-tauri/src/services/sync_engine.rs — runs background tokio task, processes SyncCommand enum (TriggerSync, UpdateConfig, Stop) via mpsc channel
- SyncHandle stored as Tauri managed state, has send() method to send commands to the sync engine
- Approval commands in src-tauri/src/commands/approval.rs — approve_mr and unapprove_mr enqueue actions via sync_queue then return immediately
- Sync queue in src-tauri/src/services/sync_queue.rs — enqueue_action(), get_pending_actions(), process via sync_processor
- Sync processor in src-tauri/src/services/sync_processor.rs — process_action() handles individual action execution against GitLab API
- ActionType enum includes Approve, Comment, Reply, Resolve, Unresolve
- Approval commands currently only take pool: State<SqlitePool> — need to also accept SyncHandle state
- Command registration: src-tauri/src/commands/mod.rs (re-exports) and src-tauri/src/lib.rs (generate_handler!)
- GitLab client: approve_merge_request() and unapprove_merge_request() POST endpoints in gitlab_client.rs
- SyncCommand now has FlushApprovals variant; SyncHandle has flush_approvals() convenience method
- flush_approval_actions() on SyncEngine filters pending actions by ActionType::Approve, looks up instance per MR, creates client, and processes each action

---

## 2026-02-06 - US-001
- What was implemented: Added `FlushApprovals` variant to `SyncCommand` enum, handled it in the sync engine background loop, added `flush_approvals()` convenience method on `SyncHandle`, and added `flush_approval_actions()` on `SyncEngine` that filters pending actions to only approval types and processes them individually.
- Files changed: src-tauri/src/services/sync_engine.rs
- **Learnings for future iterations:**
  - The flush_approval_actions method needs to look up the instance_id from the merge_requests table for each action, since actions don't store instance_id directly
  - Each approval action may belong to a different GitLab instance, so the method creates a client per action (could be optimized to cache clients per instance if needed)
  - The existing `process_action` from sync_processor handles all status transitions (mark_syncing, mark_synced, mark_failed) so the flush just needs to call it
  - ActionType::Approve covers both approve and unapprove (the payload distinguishes them via the "action" field)
---

