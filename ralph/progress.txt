## Codebase Patterns
- SyncEngine::new() requires (DbPool, AppHandle) - AppHandle needed for event emission
- SyncEngine::start_background() requires (DbPool, SyncConfig, AppHandle)
- get_sync_status command creates ephemeral SyncEngine just for log queries - must pass AppHandle
- `use tauri::Emitter` is needed wherever `app_handle.emit()` is called
- sync_events.rs defines all event constants and payload structs - use those, don't create new ones
- Event emission failures should be logged but never abort sync (use `let _ = app_handle.emit(...)` or log on Err)

---

## 2026-02-09 - US-001
- What was implemented: Added AppHandle field to SyncEngine struct and threaded it through start_background() and lib.rs setup
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added `app_handle: tauri::AppHandle` field to SyncEngine, updated `new()` and `start_background()` signatures, added `use tauri::Emitter`
  - `src-tauri/src/lib.rs`: Pass `app.handle().clone()` to `SyncEngine::start_background()`
  - `src-tauri/src/commands/sync.rs`: Updated `get_sync_status` to accept `AppHandle` and pass it to `SyncEngine::new()`
- **Learnings for future iterations:**
  - `app.handle().clone()` in Tauri v2 setup closure gives you the AppHandle
  - `get_sync_status` command creates a temporary SyncEngine just for DB log queries - it needs AppHandle too
  - Warnings about unused `app_handle` and `Emitter` are expected until US-002 starts using them
---

## 2026-02-09 - US-002
- What was implemented: Added sync-progress event emissions throughout run_sync flow
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added emit_progress() helper, imported SyncProgressPayload/SyncPhase/SYNC_PROGRESS_EVENT. Emit events for: starting, fetching_mrs (per instance with URL), fetching_diff (per MR), fetching_comments (per MR), pushing_actions, purging, complete (with MR count and duration), failed (with error message)
- **Learnings for future iterations:**
  - emit_progress() helper keeps emit calls concise - just pass phase + message
  - Complete/failed events need special handling (processed/total/is_error fields) so they use direct emit calls
  - All event emissions use log::warn on failure, never abort sync
---

## 2026-02-09 - US-003
- What was implemented: Added mr-updated event emissions at each sync phase per MR
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added emit_mr_updated() helper, imported MrUpdatedPayload/MrUpdateType/MR_UPDATED_EVENT. Emit events for: created (new MR first insert), updated (existing MR metadata change), diff_updated (after diff upsert), comments_updated (after discussions upsert), purged (for each MR removed from cache). Changed purge query to SELECT id,iid for event payload.
- **Learnings for future iterations:**
  - To determine created vs updated: query `SELECT id FROM merge_requests WHERE id = ?` before upsert
  - purge_closed_mrs needed `iid` in addition to `id` for the MrUpdatedPayload - changed to `(i64, i64)` tuple
  - emit_mr_updated() helper keeps calls clean: just pass mr_id, instance_id, iid, update_type
---

## 2026-02-09 - US-004
- What was implemented: Added action-synced event emissions during push_pending_actions and flush_approval_actions
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Imported ActionSyncedPayload/ACTION_SYNCED_EVENT. Emit action-synced events after each action in push_pending_actions results loop and after each flush_approval_actions process_action call.
- **Learnings for future iterations:**
  - ProcessResult has `action: SyncAction` which has id, mr_id, action_type, local_reference_id - all needed for ActionSyncedPayload
  - Both push_pending_actions (in sync_instance) and flush_approval_actions (FlushApprovals command) need action-synced events for consistency
---

## 2026-02-09 - US-005
- What was implemented: Added auth-expired event emission when sync encounters authentication errors
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Imported AuthExpiredPayload/AUTH_EXPIRED_EVENT. In run_sync() instance error handler, check `e.is_authentication_expired()` and emit auth-expired event with instance details. Sync continues with remaining instances.
- **Learnings for future iterations:**
  - AppError has helper methods: `is_authentication_expired()`, `get_expired_instance_id()`, `get_expired_instance_url()` for extracting instance info from auth errors
  - Auth errors from sync_instance already propagate with instance info via `authentication_expired_for_instance()` constructor
  - The error handler in run_sync's instance loop already skips failed instances and continues
---
