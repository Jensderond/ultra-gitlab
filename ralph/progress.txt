## Codebase Patterns
- SyncEngine::new() requires (DbPool, AppHandle) - AppHandle needed for event emission
- SyncEngine::start_background() requires (DbPool, SyncConfig, AppHandle)
- get_sync_status command creates ephemeral SyncEngine just for log queries - must pass AppHandle
- `use tauri::Emitter` is needed wherever `app_handle.emit()` is called
- sync_events.rs defines all event constants and payload structs - use those, don't create new ones
- Event emission failures should be logged but never abort sync (use `let _ = app_handle.emit(...)` or log on Err)

---

## 2026-02-09 - US-001
- What was implemented: Added AppHandle field to SyncEngine struct and threaded it through start_background() and lib.rs setup
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added `app_handle: tauri::AppHandle` field to SyncEngine, updated `new()` and `start_background()` signatures, added `use tauri::Emitter`
  - `src-tauri/src/lib.rs`: Pass `app.handle().clone()` to `SyncEngine::start_background()`
  - `src-tauri/src/commands/sync.rs`: Updated `get_sync_status` to accept `AppHandle` and pass it to `SyncEngine::new()`
- **Learnings for future iterations:**
  - `app.handle().clone()` in Tauri v2 setup closure gives you the AppHandle
  - `get_sync_status` command creates a temporary SyncEngine just for DB log queries - it needs AppHandle too
  - Warnings about unused `app_handle` and `Emitter` are expected until US-002 starts using them
---

## 2026-02-09 - US-002
- What was implemented: Added sync-progress event emissions throughout run_sync flow
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added emit_progress() helper, imported SyncProgressPayload/SyncPhase/SYNC_PROGRESS_EVENT. Emit events for: starting, fetching_mrs (per instance with URL), fetching_diff (per MR), fetching_comments (per MR), pushing_actions, purging, complete (with MR count and duration), failed (with error message)
- **Learnings for future iterations:**
  - emit_progress() helper keeps emit calls concise - just pass phase + message
  - Complete/failed events need special handling (processed/total/is_error fields) so they use direct emit calls
  - All event emissions use log::warn on failure, never abort sync
---

## 2026-02-09 - US-003
- What was implemented: Added mr-updated event emissions at each sync phase per MR
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Added emit_mr_updated() helper, imported MrUpdatedPayload/MrUpdateType/MR_UPDATED_EVENT. Emit events for: created (new MR first insert), updated (existing MR metadata change), diff_updated (after diff upsert), comments_updated (after discussions upsert), purged (for each MR removed from cache). Changed purge query to SELECT id,iid for event payload.
- **Learnings for future iterations:**
  - To determine created vs updated: query `SELECT id FROM merge_requests WHERE id = ?` before upsert
  - purge_closed_mrs needed `iid` in addition to `id` for the MrUpdatedPayload - changed to `(i64, i64)` tuple
  - emit_mr_updated() helper keeps calls clean: just pass mr_id, instance_id, iid, update_type
---

## 2026-02-09 - US-004
- What was implemented: Added action-synced event emissions during push_pending_actions and flush_approval_actions
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Imported ActionSyncedPayload/ACTION_SYNCED_EVENT. Emit action-synced events after each action in push_pending_actions results loop and after each flush_approval_actions process_action call.
- **Learnings for future iterations:**
  - ProcessResult has `action: SyncAction` which has id, mr_id, action_type, local_reference_id - all needed for ActionSyncedPayload
  - Both push_pending_actions (in sync_instance) and flush_approval_actions (FlushApprovals command) need action-synced events for consistency
---

## 2026-02-09 - US-005
- What was implemented: Added auth-expired event emission when sync encounters authentication errors
- Files changed:
  - `src-tauri/src/services/sync_engine.rs`: Imported AuthExpiredPayload/AUTH_EXPIRED_EVENT. In run_sync() instance error handler, check `e.is_authentication_expired()` and emit auth-expired event with instance details. Sync continues with remaining instances.
- **Learnings for future iterations:**
  - AppError has helper methods: `is_authentication_expired()`, `get_expired_instance_id()`, `get_expired_instance_url()` for extracting instance info from auth errors
  - Auth errors from sync_instance already propagate with instance info via `authentication_expired_for_instance()` constructor
  - The error handler in run_sync's instance loop already skips failed instances and continues
---

## 2026-02-09 - US-006
- What was implemented: Auto-refresh frontend components on sync events
- Files changed:
  - `src/components/MRList/MRList.tsx`: Added `listen` import from `@tauri-apps/api/event`. Added debounced (500ms) mr-updated event listener that triggers `loadMRs(true)` for background refresh.
  - `src/pages/MRDetailPage.tsx`: Added `listen` import. Added mr-updated event listener that re-fetches MR data, files, and diff refs when the event matches the currently viewed MR ID.
  - `src/hooks/useSyncStatus.ts`: No changes needed - already handles sync-progress (isSyncing, lastSyncTime, lastSyncMrCount, error), action-synced (fetchStatus for counts), and mr-updated (newMrsCount tracking)
- **Learnings for future iterations:**
  - MRList debounce pattern: clear timer on each event, only fire loadMRs after 500ms quiet period — handles bursts of 50-100+ events efficiently
  - MRDetailPage filters events by `event.payload.mr_id !== mrId` to only re-fetch when the current MR is updated
  - `listen()` returns a Promise<UnlistenFn> — must use `.then()` pattern since it can't go in useEffect's synchronous body
---

## 2026-02-09 - US-007
- What was implemented: Removed polling from useSyncStatus, replaced with event-driven-only updates
- Files changed:
  - `src/hooks/useSyncStatus.ts`: Removed `UseSyncStatusOptions` interface (pollInterval, autoPoll options). Removed options parameter from `useSyncStatus()`. Replaced polling `useEffect` (setInterval) with simple one-time `fetchStatus()` on mount.
- **Learnings for future iterations:**
  - No callers were passing options to useSyncStatus, so removing the interface was clean
  - The sync-progress event listener already handles isSyncing/lastSyncTime/error updates
  - The action-synced event listener already calls fetchStatus() for action counts
  - Initial fetch on mount is still needed to populate state before any events fire
---
